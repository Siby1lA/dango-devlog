---
title: '일본어 한자에 후리가나 적용기3'
date: '2023-07-26'
tags: ['후리가나', '리액트네이티브']
draft: false
summary: '일단냥 예문에 후리가나를 적용하기 위해 시도했던 것들'
poster: '/static/images/main.png'
---

# Furigana가 뭐예요?

![](https://velog.velcdn.com/images/psb7391/post/56eeb53e-141a-4892-af6d-881a9f26de0f/image.png)
Furigana는 루비 문자라고도 불리며 일본어에서 한자를 읽는 법을 한자 위(근처)에 표시해 주는 문자에요 일본어 한자는 읽는 방법이 여러 가지이며 자주 사용하지 않은 한자들의 경우 읽는 법을 알려주기 위해 Furigana를 자주 사용한답니다.

# 일단냥에는 Furigana가 없었어요?

![](https://velog.velcdn.com/images/psb7391/post/d9d0055c-7d85-4cc3-a321-804d459b12e5/image.PNG)

네 기존의 일단냥에는 Furigana가 없었어요. 그 대신에 한자에 대한 발음이 아닌 모든 발음을 썼었는데 이는 개발 당시 제 실력이 부족했어서 Furigana 없이 만들었었어요.

2년 전에 개발한 [JLPT 단어앱](https://github.com/Siby1lA/jlpt-tango) 개발 당시 문자열에서 한자를 어떻게 구별하고 그 위에 Furigana를 넣어야 하는지 감이 안 잡혔었어요 그래서 그냥 모든 발음을 예문 위에 표시하자! 하고 개발해서 위 사진과 같이 되었답니다..

> JLPT 단어앱은 일단냥 이전의 앱

갑자기 일단냥에 Furigana를 표기하려고 한 계기가 있어요 최근에 디자이너가 합류하게 되었는데 회의를 하다가 Furigana를 표기하는 걸로 바꾸면 더 이쁠 거 같고 가독성도 좋아질 거 같다고 결론이 나서 이번 기회에 Furigana를 달려고 했어요

# Furigana는 어떻게 달았죠?

일단냥이 생각한 방법 중 Furigana를 달기 위한 방법은 2가지였어요.

## 첫 번째 안

```
{
     "reibun":"紅葉が落ちる秋",
     "reibunFurigana":"こうようがおちるあき"
}
```

reibun인 `紅葉が落ちる秋`와 reibunFurigana인 `こうようがおちるあき`를 비교해서 겹치는 문자가 있는지 확인하고 추출을 하면 `が, ちる`가 겹치게 돼요. 여기서 겹치는 문자를 reibun에서 제거하면 `紅葉, 落, 秋`가 남고 한자가 들어있는 reibunFurigana인 제거하면 `こうよう, お, あき`예요.

그러고 나서 split()으로 분리하면 아래와 같이 데이터를 만들 수 있을 거예요

```
{
     "reibun":['紅葉', '落', '秋'],
     "reibunFurigana":['こうよう', 'お', 'あき']
}
```

하지만 이 방법에는 아래와 같은 경우 치명적인 단점이 있어요

```
{
     "reibun":"今侍が来る",
     "reibunFurigana":"いまさむらいがくる"
}
```

![](https://velog.velcdn.com/images/psb7391/post/e6e13dc5-d9dc-4f1e-93d1-028726c6aef8/image.png)
今와 侍는 따로 분리된 단어인데 분리가 안된다는 사실이예요 분리가 안되면 Furigana가 いまさむらい로 고정인데 今의 Furigana いま, 侍의 Furigana さむらい인 것을 컴퓨터는 몰라서 올바른 한자 위에 위치하지 못한다는 점이 있었어요. 특히 侍처럼 한자의 발음이 긴 경우 오히려 Furigana에 혼동이 갈 거라고 생각했어요

즉 今侍에서 いまさむらい로 구분이 되었는데 今가 어디까지 Furigana로 써야 하는지 侍도 어디까지 써야 하는 Furigana인지 구분할 수가 없었어요

## 두 번째 안

두 번째 안은 한자를 히라가나로 바꿔주는 kanji to hiragana 라이브러리를 여러 개 찾아봤는데 3가지가 있었어요.

1. wanakana : https://wanakana.com/
2. mecab : https://github.com/hecomi/node-mecab-async
3. kuroshiro : https://www.npmjs.com/package/kuroshiro

### wanakana

wanakana는 히라가나나 카타카나를 로마자로 바꿔주거나 그 반대의 기능이 있었고 한자, 히라가나, 카타카나인지 구분해 주는 기능들이 있었어요 일단냥에 Furigana를 달기에는 적합하지 않아서 패스했습니다.

### mecab

반면 mecab은 한자를 카타카나와 동사, 명사와 같이 구분까지 해줘서 일단냥에 Furigana로 쓰기에 차고 넘치는 기능이었어요.

`いつもニコニコあなたの隣に這い寄る混沌ニャルラトホテプです！` 라는 문자열로 요청하면

```
[ [ 'いつも', '副詞', '一般', '*', '*', '*', '*', 'いつも', 'イツモ', 'イツモ' ],
  [ 'ニコニコ', '副詞', '助詞類接続', '*', '*', '*', '*', 'ニコニコ', 'ニコニコ', 'ニコニコ' ],
  [ 'あなた', '名詞', '代名詞', '一般', '*', '*', '*', 'あなた', 'アナタ', 'アナタ' ],
  [ 'の', '助詞', '連体化', '*', '*', '*', '*', 'の', 'ノ', 'ノ' ],
  [ '隣', '名詞', '一般', '*', '*', '*', '*', '隣', 'トナリ', 'トナリ' ],
  [ 'に', '助詞', '格助詞', '一般', '*', '*', '*', 'に', 'ニ', 'ニ' ],
  [ '這い', '動詞', '自立', '*', '*', '五段・ワ行促音便', '連用形', '這う', 'ハイ', 'ハイ' ],
  [ '寄る', '動詞', '自立', '*', '*', '五段・ラ行', '基本形', '寄る', 'ヨル', 'ヨル' ],
  [ '混沌', '名詞', '一般', '*', '*', '*', '*', '混沌', 'コントン', 'コントン' ],
  [ 'ニャルラトホテプ', '名詞', '一般', '*', '*', '*', '*', '*' ],
  [ 'です', '助動詞', '*', '*', '*', '特殊・デス', '基本形', 'です', 'デス', 'デス' ],
  [ '！', '記号', '一般', '*', '*', '*', '*', '！', '！', '！' ] ]
```

이렇게 많은 정보를 리턴해주는 기능이 있는데 발음을 히라가나가 아닌 카타카나로 리턴해 준다는 단점이 있어요. 그래서 여기서 받은 카타카나를 위의 wanakana를 사용해 히라가나로 바꾸면 Furigana를 달 수 있겠다! 생각하고 mecab를 사용하는데 계속해서 빈 객체가 리턴되었어요.

그래서 해당 [레포의 이슈](https://github.com/hecomi/node-mecab-async/issues/16)를 봤는데 저와 같은 이슈를 올렸던 사람이 이제 지원하지 않는 라이브러리냐고 묻는 거에 답변도 없는걸 봐서는 이제 지원하지 않는다고 생각했어요. 심지어 최신 커밋이 6년 전이어서 납득이 갔어요.
그래서 안타깝게 mecab를 사용하지 못했어요.

### kuroshiro

```
// okurigana
await kuroshiro.convert("感じ取れたら手を繋ごう、重なるのは人生のライン and レミリア最高！", {mode:"okurigana", to:"hiragana"});
// result: 感(かん)じ取(と)れたら手(て)を繋(つな)ごう、重(かさ)なるのは人生(じんせい)のライン and レミリア最高(さいこう)！
// furigana
await kuroshiro.convert("感じ取れたら手を繋ごう、重なるのは人生のライン and レミリア最高！", {mode:"furigana", to:"hiragana"});
// result: 感かんじ取とれたら手てを繋つなごう、重かさなるのは人生じんせいのライン and レミリア最高さいこう！
```

kuroshiro는 okurigana와 furigana를 완벽 지원했어요 mode를 Furigana로 해서 리턴하면

> ボーちゃんに<ruby>綺麗<rp>(</rp><rt>きれい</rt><rp>)</rp></ruby>な<ruby>石<rp>(</rp><rt>いし</rt><rp>)</rp></ruby>をプレゼントした
> `ボーちゃんに<ruby>綺麗<rp>(</rp><rt>きれい</rt><rp>)</rp></ruby>な<ruby>石<rp>(</rp><rt>いし</rt><rp>)</rp></ruby>をプレゼントした`

이렇게 일단냥에서 원하는 Furigana 데이터를 html 태그와 함께 출력해 주었어요.
일단냥에 사용하기에 완벽하게 맞아떨어지는 기능이였죠 그래서 kuroshiro를 사용하기로 마음먹었어요.

사용은 해도 일단냥에서 해당 예문을 조회할 때마다 `kuroshiro`를 써서 의존도를 높이고 싶지 않았어요

```
origData.map(async (item) => {
	const { reibunFurigana, ...rest } = item;
	return {
		...rest,
		reibunHtml: await trans(item.reibun),
	};
})
```

그래서 프로그램을 하나 만들어서 일단냥의 예문이 들어있는 json 파일을 다시 구성했답니다.
여기서 trans가 kuroshiro를 통해 Furigana를 반환해 주는 함수예요.

```
{
        "kanji": "石",
        "imi": "돌",
        "hurigana": "いし",
        "reibun": "ボーちゃんに綺麗な石をプレゼントした",
        "reibunImi": "맹구에게 예쁜 돌을 선물했다",
        "reibunHtml": "ボーちゃんに<ruby>綺麗<rp>(</rp><rt>きれい</rt><rp>)</rp></ruby>な<ruby>石<rp>(</rp><rt>いし</rt><rp>)</rp></ruby>をプレゼントした"
},
```

이렇게 다시 단어장 데이터들을 이쁘게 정렬했고 kuroshiro의 의존도를 없앨 수 있었어요 의존도가 없어져서 kuroshiro가 더 이상 지원하지 않는다던가 엄청 큰 이슈가 생겨도 일단냥에는 문제가 없게 된 것이죠

이제 일단냥에 적용하려고 사용해 보니 `<ruby />`는 html 태그여서 리액트네이티브에서 적용이 안되는 이슈가 있었어요

![](https://velog.velcdn.com/images/psb7391/post/08df9637-a243-4bf5-b9b3-a830e4b211ac/image.png)

웹에서는 html의 `<ruby />`를 지원해서 Furigana가 이쁘게 표시되었지만
![](https://velog.velcdn.com/images/psb7391/post/570b4ab8-d423-4d80-9a6a-1a7c80e8255e/image.png)

일단냥 단어장은 리액트네이티브에서 실행되기에 `<ruby />` 가 있지 않았어요
그래서 html 태그를 랜더링하기 위해 [react-native-render-html](https://www.npmjs.com/package/react-native-render-html) 라이브러리를 써봤더니 `<rt />`가 적용되지 않아서 ()로 대체가 되었어요

# 그래서 ruby 태그를 지원하지 않는 리액트네이티브에서 어떻게 Furigana를 구현했어요?

위에서 [react-native-render-html](https://www.npmjs.com/package/react-native-render-html)를 통해 html를 랜더링해도 ruby태그를 지원하지 않아 kuroshiro에서 추출한 `ボーちゃんに<ruby>綺麗<rp>(</rp><rt>きれい</rt><rp>)</rp></ruby>な<ruby>石<rp>(</rp><rt>いし</rt><rp>)</rp></ruby>をプレゼントした` 데이터를 가지고 커스텀 Furigana를 만들려고 했어요

```
const reibunSepar = reibun?.split(/<ruby>(.*?)<\/ruby>/g).filter(Boolean);

// 결과
LOG
["将来<rp>(</rp><rt>しょうらい</rt><rp>)</rp>",
"看護<rp>(</rp><rt>かんご</rt><rp>)</rp>",
"士<rp>(</rp><rt>し</rt><rp>)</rp>",
"になりたい"]
```

예문을 가지고 정규식 표현으로 `<ruby />`가 있을 때 split()으로 분리시키면 LOG와 같이 Furigana가 있는 한자끼리 묶여있는 배열이 만들어져요

이렇게 한자별로 해당하는 Furigana가 구분되어 있어 Furigana 표기에 수월해졌어요 근데 여기서 또 사용자가 Furigana를 제대로 보게 하려면 `(</rp><rt>しょうらい</rt><rp>)</rp>` 에서 しょうらい만 남게 Furigana만 추출해야 해요

```
const furigana = reibunSepar.match(/<rt>(.*?)<\/rt>/)?.[1] || " ";

// 결과
LOG  しょうらい
LOG  かんご
LOG  し
LOG
```

이것도 정규식 표현으로 화면 표시에 불필요한 태그들을 다 지웠어요 즉 해당 Furigana를 구별하기 위해 태그를 기반으로 찾았지만 화면 표시에는 필요 없으니 해당 태그를 지워버린 것이에요.

근데 왜 `okurigana`로 하면 html 태그가 아닌 `()`로 구분되어 있어 더 편할 텐데 이 방식으로 했냐고 물은다면 추후 ruby 태그를 지원하는 라이브러리를 찾아 그때 적용해 볼 수도 있고 일단냥 예문을 수정하는 관리자 사이트(웹)에서도 Furigana를 편하게 보기 위해 이런 귀찮은 작업들을 하게 되었어요

![](https://velog.velcdn.com/images/psb7391/post/b1188b48-f95d-470b-8b41-4e5dbf7ac426/image.png)

아무튼 본론으로 들어가 문자열을 추출해서 위와 같이 이쁘게 Furigana를 달게 되었어요!

그런데..! 긴 예문에서 이슈가 생겼어요

## 문자열 표기 이슈

![](https://velog.velcdn.com/images/psb7391/post/f3004b33-a147-47dd-85eb-cd223c5adc6d/image.png)

한자랑 Furigana를 묶고 그 외의 예문을 분리하고 나서 Furigana가 없는 문자들을 보면

```
LOG  この
LOG  はいつ
LOG  てられたのですか
```

인데 마지막의 てられたのですか가 너무 길어서 저 여백을 넘어가서 공백이 생겼어요
css의 flex-wrap: wrap로 인해 자동개행이 되어서 てられたのですか의 길이만큼의 공백이 생긴 거였죠.

그 원인은 그냥 문자열이었으면 공백 없이 표시되었을 것을 일단냥은 Furigana를 위해 문자열들을 분리하고 하나하나 map()으로 넣어줬으니 단어별로 독립된 문자열이기 때문에 저런 현상이 발생했던 것이였지요.

```
// hugigana가 " " 공백이고 reibun이 2글자 이상일 때 한자와 Furigana가 아니기에 분리 시킴
if (furigana === " " && reibun.length >= 2) {
     return Array.from(reibun).map((character) => ({
        furigana: " ",
       reibun: character,
     }));
} else {
     return [{ furigana, reibun }];
}

[{"furigana": "", "reibun": "こ"},
{"furigana": "", "reibun": "の"},
{"furigana": "きょうかい", "reibun": "教会"},
{"furigana": " ", "reibun": "は"},
{"furigana": " ", "reibun": "い"},
{"furigana": " ", "reibun": "つ"},
{"furigana": "た", "reibun": "建"},
{"furigana": " ", "reibun": "て"},
{"furigana": " ", "reibun": "ら"},
{"furigana": " ", "reibun": "れ"},
{"furigana": " ", "reibun": "た"},
{"furigana": " ", "reibun": "の"},
...]
```

그래서 심플하게 " " 공백이고 reibun이 2글자 이상일 때 한자와 Furigana가 아니기에. Furigana가 포함되지 않은 예문의 문자열들도 1개씩 분리했어요

![](https://velog.velcdn.com/images/psb7391/post/8be608c7-c397-441b-bb1e-9e2b974d6f30/image.png)

그랬더니 기존 `<Text>` 태그처럼 매끄럽게 줄바꿈이 되었어요

# 깨달은 사실

![](https://velog.velcdn.com/images/psb7391/post/f425ccdb-87ec-4287-8659-e5e0d27f2158/image.png)

1. 이렇게 간단한 Furigana를 표기하는 데 있어 개발하는 환경에 따라 쉽게 구현할 수도 어렵게 구현할 수도 있다는 사실을 알았어요.

2. 라이브러리의 의존도가 너무 높으면 위험하다는 것을 몸소 느꼈어요 mecab처럼 추후에 해당 라이브러리가 지원하지 않게 되는 순간 유저들이 서비스를 제대로 사용하지 못하고 개발자도 다른 대체 라이브러리를 찾아야 해서 큰일이 될꺼라고 생각했어요

3. 문자열을 자유롭게 다루는 능력이 부족해서 위 방식처럼 Furigana를 구현하는데 시간이 꽤 걸렸어요 그래서 알고리즘을 써서 문제를 해결하는 능력이 매우 중요하다는 것을 깨달았어요
